SSH Keys, Commands and Management
==================================

SSH, or Secure Shell, is a protocol used to securely log onto remote systems. It is the most common way to access remote Linux and Unix-like servers.


## How SSH Works

When you connect through SSH, you will be dropped into a shell session, which is a text-based interface where you can interact with your server. For the duration of your SSH session, any commands that you type into your local terminal are sent through an encrypted SSH tunnel and executed on your server.

The SSH connection is implemented using a client-server model. This means that for an SSH connection to be established, the remote machine must be running a piece of software called an SSH daemon. This software listens for connections on a specific network port, authenticates connection requests, and spawns the appropriate environment if the user provides the correct credentials.

The user's computer must have an SSH client. This is a piece of software that knows how to communicate using the SSH protocol and can be given information about the remote host to connect to, the username to use, and the credentials that should be passed to authenticate. The client can also specify certain details about the connection type they would like to establish.


## How SSH Authenticates Users

Clients generally authenticate either using passwords (less secure and not recommended) or SSH keys, which are very secure.

Password logins are encrypted and are easy to understand for new users. However, automated bots and malicious users will often repeatedly try to authenticate to accounts that allow password-based logins, which can lead to security compromises. For this reason, we recommend always setting up SSH key-based authentication for most configurations.

SSH keys are a matching set of cryptographic keys which can be used for authentication. Each set contains a public and a private key. The public key can be shared freely without concern, while the private key must be vigilantly guarded and never exposed to anyone.

To authenticate using SSH keys, a user must have an `SSH key pair` on their local computer. On the remote server, the public key must be copied to a file within the user's home directory at `~/.ssh/authorized_keys`. This file contains a list of public keys, one-per-line, that are authorized to log into this account.

When a client connects to the host, wishing to use SSH key authentication, it will inform the server of this intent and will tell the server which public key to use. The server then check its authorized_keys file for the public key, generate a random string and encrypts it using the public key. This encrypted message can only be decrypted with the associated private key. The server will send this encrypted message to the client to test whether they actually have the associated private key.

Upon receipt of this message, the client will decrypt it using the private key and combine the random string that is revealed with a previously negotiated session ID. It then generates an MD5 hash of this value and transmits it back to the server. The server already had the original message and the session ID, so it can compare an MD5 hash generated by those values and determine that the client must have the private key.

Now that you know how SSH works, we can begin to discuss some examples to demonstrate different ways of working with SSH


## Basic Syntax
The tool on Linux for connecting to a remote system using SSH is called, unsurprisingly, `ssh`.

The most basic form of the command is:

    $ ssh remote_host

The remote_host in this example is the IP address or domain name that you are trying to connect to.

This command assumes that your username on the remote system is the same as your username on your local system.

If your username is different on the remote system, you can specify it by using this syntax:

    $ ssh remote_username@remote_host

Once you have connected to the server, you will probably be asked to verify your identity by providing a password.

Later, we will cover how to generate keys to use instead of passwords.

On Ubuntu, you can start the ssh server on the Droplet by typing:

    $ sudo service ssh start

On Ubuntu 16.04 and Debian Jessie, you can use systemctl, the systemd command for managing services:

    $ sudo systemctl start ssh

That should start the sshd server and you can then log in remotely.


## How To Configure SSH

When you change the configuration of SSH, you are changing the settings of the sshd server.

In `Ubuntu`, the main sshd configuration file is located at `/etc/ssh/sshd_config`.

Back up the current version of this file before editing:

    $ sudo cp /etc/ssh/sshd_config{,.bak}

Open it with a text editor:

    $ sudo vi /etc/ssh/sshd_config

You will want to leave most of the options in this file alone. However, there are a few you may want to take a look at:

    # /etc/ssh/sshd_config
    Port 22

The port declaration specifies which port the sshd server will listen on for connections. By default, this is `22`. You should probably leave this setting alone, unless you have specific reasons to do otherwise. If you do change your port, we will show you how to connect to the new port later on.

    # /etc/ssh/sshd_config
    HostKey /etc/ssh/ssh_host_rsa_key
    HostKey /etc/ssh/ssh_host_dsa_key
    HostKey /etc/ssh/ssh_host_ecdsa_key

The host keys declarations specify where to look for global host keys. We will discuss what a host key is later.

    # /etc/ssh/sshd_config
    SyslogFacility AUTH
    LogLevel INFO

These two items indicate the level of logging that should occur.

If you are having difficulties with SSH, increasing the amount of logging may be a good way to discover what the issue is.

    # /etc/ssh/sshd_config
    LoginGraceTime 120
    PermitRootLogin yes
    StrictModes yes

These parameters specify some of the login information.

`LoginGraceTime` specifies how many seconds to keep the connection alive without successfully logging in.

It may be a good idea to set this time just a little bit higher than the amount of time it takes you to log in normally.

`PermitRootLogin` selects whether root is allowed to log in.

In most cases, this should be changed to "no" when you have created user account that has access to elevated privileges (through `su` or `sudo`) and can log in through ssh.

`strictModes` is a safety guard that will refuse a login attempt if the authentication files are readable by everyone.

This prevents login attempts when the configuration files are not secure.

    # /etc/ssh/sshd_config
    X11Forwarding yes
    X11DisplayOffset 10

These parameters configure an ability called `X11 Forwarding`. This allows you to view a remote system's graphical user interface (GUI) on the local system.

This option must be enabled on the server and given with the SSH client during connection with the ` -X ` option.

If you changed any settings in `/etc/ssh/sshd_config`, make sure you restart your `sshd` server to implement your modifications:

    $ sudo service ssh restart

Or, on `systemd` systems such as `Ubuntu 16.04 or Debian Jessie`:

    $ sudo systemctl restart ssh

You should thoroughly test your changes to ensure that they operate in the way you expect.

It may be a good idea to have a few sessions active when you are making changes. This will allow you to revert the configuration if necessary.


## How Does Key-based Authentication Work?

`Key-based authentication` works by creating a pair of keys: a private key and a public key.

The `private key` is located on the client machine and is secured and kept secret.

The `public key` can be given to anyone or placed on any server you wish to access.

When you attempt to connect using a `key-pair`, the server will use the public key to create a message for the client computer that can only be read with the private key.

The client computer then sends the appropriate response back to the server and the server will know that the client is legitimate.

This entire process is done in the background automatically after you set up keys.

## How To Create SSH Keys

SSH keys should be generated on the computer you wish to log in from. This is usually your local computer.

Enter the following into the command line:

    $ ssh-keygen -t rsa

Press enter to accept the defaults. Your keys will be created at `~/.ssh/id_rsa.pub` and `~/.ssh/id_rsa`.

Or, you can do it differenly **(non default setup)**

    Generating public/private rsa key pair.
    Enter file in which to save the key (/home/demo/.ssh/id_rsa):

This prompt allows you to choose the location to store your `RSA private key`. Press `ENTER` to leave this as the default, which will store them in the `.ssh` hidden directory in your `user's home directory`. Leaving the default location selected will allow your SSH client to find the keys automatically.

    Enter passphrase (empty for no passphrase):
    Enter same passphrase again:

The next prompt allows you to enter a `passphrase` of an arbitrary length to secure your private key. By default, you will have to enter any passphrase you set here every time you use the private key, as an additional security measure. Feel free to press `ENTER` to leave this blank if you do not want a passphrase. Keep in mind though that this will allow anyone who gains control of your private key to login to your servers.

It's up to you whether you want to use a passphrase. Entering a passphrase does have its benefits: the security of a key, no matter how encrypted, still depends on the fact that it is not visible to anyone else. Should a passphrase-protected private key fall into an unauthorized users possession, they will be unable to log in to its associated accounts until they figure out the passphrase, buying the hacked user some extra time. The only downside, of course, to having a passphrase, is then having to type it in each time you use the Key Pair.

If you choose to enter a passphrase, nothing will be displayed as you type. This is a security precaution.

    Your identification has been saved in /root/.ssh/id_rsa.
    Your public key has been saved in /root/.ssh/id_rsa.pub.
    The key fingerprint is:
    8c:e9:7c:fa:bf:c4:e5:9c:c9:b8:60:1f:fe:1c:d3:8a root@here
    The key's randomart image is:
    +--[ RSA 2048]----+
    |                 |
    |                 |
    |                 |
    |       +         |
    |      o S   .    |
    |     o   . * +   |
    |      o + = O .  |
    |       + = = +   |
    |      ....Eo+    |
    +-----------------+

This procedure has generated an RSA SSH key pair, located in the `.ssh` hidden directory within your user's home directory.

Change into the `.ssh` directory by typing:

    $ cd ~/.ssh

Look at the permissions of the files:

    $ ls -l
    # Output
    -rw-r--r-- 1 demo demo  807 Sep  9 22:15 authorized_keys
    -rw------- 1 demo demo 1679 Sep  9 23:13 id_rsa
    -rw-r--r-- 1 demo demo  396 Sep  9 23:13 id_rsa.pub

As you can see, the `id_rsa` file is readable and writable only to the owner. This is how it should be to keep it secret.

The `id_rsa.pub` file, however, can be shared and has permissions appropriate for this activity.

## Generate an SSH Key Pair with a Larger Number of Bits

SSH keys are `2048 bits` by default. This is generally considered to be good enough for security, but you can specify a greater number of bits for a more hardened key.

To do this, include the `-b` argument with the number of bits you would like. Most servers support keys with a length of at least `4096 bits`. Longer keys may not be accepted for `DDOS protection purposes`:

    $ ssh-keygen -b 4096

If you had previously created a different key, you will be asked if you wish to overwrite your previous key:

    $ Overwrite (y/n)?

If you choose **"yes"**, your previous key will be overwritten and you will no longer be able to log into servers using that key. Because of this, be sure to overwrite keys with caution.

## Removing or Changing the Passphrase on a Private Key

If you have generated a passphrase for your private key and wish to change or remove it, you can do so easily.

**Note:** To change or remove the passphrase, you must know the original passphrase. If you have lost the passphrase to the key, there is no recourse and you will have to generate a new key pair.

To change or remove the passphrase, simply type:

    $ ssh-keygen -p

    Enter file in which the key is (/root/.ssh/id_rsa):

You can type the location of the key you wish to modify or press `ENTER` to accept the default value:

    Enter old passphrase:

Enter the old passphrase that you wish to change. You will then be prompted for a new passphrase:

    Enter new passphrase (empty for no passphrase): 
    Enter same passphrase again:

Here, enter your new passphrase or press `ENTER` to remove the passphrase.

## Displaying the SSH Key Fingerprint

Each `SSH key pair` share a single cryptographic **"fingerprint"** which can be used to uniquely identify the keys. This can be useful in a variety of situations.

To find out the fingerprint of an SSH key, type:

    $ ssh-keygen -l

    Enter file in which the key is (/root/.ssh/id_rsa):

You can press `ENTER` if that is the correct location of the key, else enter the revised location. You will be given a string which contains the bit-length of the key, the fingerprint, and account and host it was created for, and the algorithm used:

    4096 8e:c4:82:47:87:c2:26:4b:68:ff:96:1a:39:62:9e:4e  demo@test (RSA)

## Copying your Public SSH Key to a Server with SSH-Copy-ID

To copy your public key to a server, allowing you to authenticate without a password, a number of approaches can be taken.

If you currently have password-based **SSH** access configured to your server, and you have the ssh-copy-id utility installed, this is a simple process. The `ssh-copy-id` tool is included in many Linux distributions' `OpenSSH` packages, so it very likely may be installed by default.

If you have this option, you can easily transfer your public key by typing:

    $ ssh-copy-id username@remote_host

This will prompt you for the user account's password on the remote system:

    The authenticity of host '111.111.11.111 (111.111.11.111)' can't be established.
    ECDSA key fingerprint is fd:fd:d4:f9:77:fe:73:84:e1:55:00:ad:d6:6d:22:fe.
    Are you sure you want to continue connecting (yes/no)? yes
    /usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
    /usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
    demo@111.111.11.111's password:

After typing in the password, the contents of your `~/.ssh/id_rsa.pub` key will be appended to the end of the user account's `~/.ssh/authorized_keys` file:

    Number of key(s) added: 1

Now try logging into the machine, with:   ` $ ssh demo@111.111.11.111 ``
and check to make sure that only the key(s) you wanted were added.
You can now log into that account without a password:

    $ ssh username@remote_host

## Copying your Public SSH Key to a Server Without SSH-Copy-ID

If you do not have the `ssh-copy-id` utility available, but still have password-based SSH access to the remote server, you can copy the contents of your public key in a different way.

You can output the contents of the key and pipe it into the ssh command. On the remote side, you can ensure that the `~/.ssh` directory exists, and then append the piped contents into the `~/.ssh/authorized_keys` file:

    $ cat ~/.ssh/id_rsa.pub | ssh username@remote_host "mkdir -p ~/.ssh && cat >> ~/.ssh/authorized_keys"

You will be asked to supply the password for the remote account:

    The authenticity of host '111.111.11.111 (111.111.11.111)' can't be established.
    ECDSA key fingerprint is fd:fd:d4:f9:77:fe:73:84:e1:55:00:ad:d6:6d:22:fe.
    Are you sure you want to continue connecting (yes/no)? yes
    demo@111.111.11.111's password:

After entering the password, your key will be copied, allowing you to log in without a password:

    ssh username@remote_IP_host

## Copying your Public SSH Key to a Server Manually

If you do not have password-based SSH access available, you will have to add your public key to the remote server manually.

On your local machine, you can find the contents of your public key file by typing:

    $ cat ~/.ssh/id_rsa.pub

    ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCqql6MzstZYh1TmWWv11q5O3pISj2ZFl9HgH1JLknLLx44+tXfJ7mIrKNxOOwxIxvcBF8PXSYvobFYEZjGIVCEAjrUzLiIxbyCoxVyle7Q+bqgZ8SeeM8wzytsY+dVGcBxF6N4JS+zVk5eMcV385gG3Y6ON3EG112n6d+SMXY0OEBIcO6x+PnUSGHrSgpBgX7Ks1r7xqFa7heJLLt2wWwkARptX7udSq05paBhcpB0pHtA1Rfz3K2B+ZVIpSDfki9UVKzT8JUmwW6NNzSgxUfQHGwnW7kj4jp4AT0VZk3ADw497M2G/12N0PPB5CnhHf7ovgy6nL1ikrygTKRFmNZISvAcywB9GVqNAVE+ZHDSCuURNsAInVzgYo9xgJDW8wUw2o8U77+xiFxgI5QSZX3Iq7YLMgeksaO4rBJEa54k8m5wEiEE1nUhLuJ0X/vh2xPff6SQ1BL/zkOhvJCACK6Vb15mDOeCSq54Cr7kvS46itMosi/uS66+PujOO+xt/2FWYepz6ZlN70bRly57Q06J+ZJoc9FfBCbCyYH7U/ASsmY095ywPsBo1XQ9PqhnN1/YOorJ068foQDNVpm146mUpILVxmq41Cj55YKHEazXGsdBIbXWhcrRf4G2fJLRcGUr9q8/lERo9oxRm5JFX6TCmj6kmiFqv+Ow9gI0x8GvaQ== demo@test

You can copy this value, and manually paste it into the appropriate location on the remote server. You will have to log into the remote server through other means (like the Cloud Provider's web console).

On the remote server, create the `~/.ssh` directory if it does not already exist:

    $ mkdir -p ~/.ssh

Afterwards, you can create or append the `~/.ssh/authorized_keys` file by typing:

    $ echo public_key_string >> ~/.ssh/authorized_keys

You should now be able to log into the remote server without a password.

## (OPTIONAL) Disable the Password for Root Login

Once you have copied your SSH keys unto your server and ensured that you can log in with the SSH keys alone, you can go ahead and restrict the root login to only be permitted via SSH keys.

In order to do this, open up the SSH config file:

    $ sudo vi /etc/ssh/sshd_config

Within that file, find the line that includes `PermitRootLogin` and modify it to ensure that users can only connect with their SSH key:

    PermitRootLogin without-password

Put the changes into effect:

    reload ssh


## Limiting the Users Who can Connect Through SSH

To explicitly limit the user accounts who are able to login through SSH, you can take a few different approaches, each of which involve editing the SSH daemon config file.

On your remote server, open this file now with root or sudo privileges:

    $ sudo vi /etc/ssh/sshd_config

The first method of specifying the accounts that are allowed to login is using the `AllowUsers` directive. Search for the `AllowUsers` directive in the file. If one does not exist, create it anywhere. After the directive, list the user accounts that should be allowed to login through SSH:

    AllowUsers user1 user2

Save and close the file. Restart the daemon to implement your changes.

On **Ubuntu/Debian**:

    $ sudo service ssh restart

If you are more comfortable with `group management`, you can use the `AllowGroups` directive instead. If this is the case, just add a single group that should be allowed SSH access (we will create this group and add members momentarily):

    AllowGroups sshmembers

Save and close the file.

Now, you can create a system group (without a home directory) matching the group you specified by typing:

    $ sudo groupadd -r sshmembers

Make sure that you add whatever user accounts you need to this group. This can be done by typing:

    sudo usermod -a -G sshmembers user1
    sudo usermod -a -G sshmembers user2

Now, restart the SSH daemon to implement your changes.

On **Ubuntu/Debian**:

    $ sudo service ssh restart

## Disabling Root Login

It is often advisable to completely disable root login through SSH after you have set up an SSH user account that has sudo privileges.

To do this, open the SSH daemon configuration file with root or sudo on your remote server.

    $ sudo vi /etc/ssh/sshd_config

Inside, search for a directive called `PermitRootLogin`. If it is commented, uncomment it. Change the value to "no":

    PermitRootLogin no

Save and close the file. To implement your changes, restart the SSH daemon.

On **Ubuntu/Debian**:

    $ sudo service ssh restart

## Allowing Root Access for Specific Commands

There are some cases where you might want to disable root access generally, but enable it in order to allow certain applications to run correctly. An example of this might be a backup routine.

This can be accomplished through the root user's `authorized_keys` file, which contains SSH keys that are authorized to use the account.

Add the key from your local computer that you wish to use for this process (we recommend creating a new key for each automatic process) to the root user's authorized_keys file on the server. We will demonstrate with the `ssh-copy-id` command here, but you can use any of the methods of copying keys we discuss in other sections:

    $ ssh-copy-id root@remote_host

Now, log into the remote server. We will need to adjust the entry in the `authorized_keys` file, so open it with root or sudo access:

    $ sudo vi /root/.ssh/authorized_keys

At the beginning of the line with the key you uploaded, add a `command= listing` that defines the command that this key is valid for. This should include the full path to the executable, plus any arguments:

    command="/path/to/command arg1 arg2" ssh-rsa ...

Save and close the file when you are finished.

Now, open the `sshd_config` file with root or sudo privileges:

    $ sudo vi /etc/ssh/sshd_config

Find the directive `PermitRootLogin`, and change the value to forced-commands-only. This will only allow SSH key logins to use root when a command has been specified for the key:

    PermitRootLogin forced-commands-only

Save and close the file. Restart the SSH daemon to implement your changes.

On **Ubuntu/Debian**:

    $ sudo service ssh restart

## Forwarding X Application Displays to the Client

The SSH daemon can be configured to automatically forward the display of `X applications` on the server to the client machine. For this to function correctly, the client must have an `X windows system` configured and enabled.

To enable this functionality, log into your remote server and edit the `sshd_config` file as root or with sudo privileges:

    $ sudo vi /etc/ssh/sshd_config

Search for the `X11Forwarding` directive. If it is commented out, uncomment it. Create it if necessary and set the value to "yes":

    X11Forwarding yes

Save and close the file. Restart your SSH daemon to implement these changes.

On **Ubuntu/Debian**:

    $ sudo service ssh restart

To connect to the server and forward an application's display, you have to pass the `-X` option from the client upon connection:

    $ ssh -X username@remote_host

Graphical applications started on the server through this session should be displayed on the local computer. The performance might be a bit slow, but it is very helpful in a pinch.

## Client-Side Configuration Options

`~/.ssh/config` or `$HOME/.ssh/config` : This is user’s own configuration file which, overrides the settings in the global client configuration file, `/etc/ssh/ssh_config`.

#### ~/.ssh/config file rules

The rules are as follows to create an ssh config file:

- You need to edit `~/.ssh/config` with a text editor such as vi.
- One config parameter per line is allowed in the configuration file with the parameter name followed by its value or values. The syntax is:
    
        config value
        config1 value1 value2

- You can use an equal sign (=) instead of whitespace between the parameter name and the values.
        
        config=value
        config1=value1 value2

- All empty lines are ignored.
- All lines starting with the hash (#) are ignored.
- All values are case-sensitive, but parameter names are not.

#### For demonstration purpose my sample setup is as follows:

- Local desktop client – **Apple OS X** or **Ubuntu Linux**.
- Remote Unix server – **OpenBSD** server running latest **OpenSSH** server.
- Remote **OpenSSH** server `ip/host: 75.126.153.206 (server1.cyberciti.biz)``
- Remote **OpenSSH** server user: `nixcraft`
- Remote **OpenSSH** port: `4242`
- Local ssh private key file path : `/nfs/shared/users/nixcraft/keys/server1/id_rsa`

Based upon the above information my ssh command is as follows:

    $ ssh -i /nfs/shared/users/nixcraft/keys/server1/id_rsa -p 4242 nixcraft@server1.cyberciti.biz

OR

    $ ssh -i /nfs/shared/users/nixcraft/keys/server1/id_rsa -p 4242 -l nixcraft server1.cyberciti.biz

You can avoid typing all of the ssh command parameters while logging into a remote machine and/or for executing commands on a remote machine. All you have to do is create an ssh config file. Open the Terminal application and create your config file by typing the following command:

    
    $ sudo vi ~/.ssh/config

OR

    $ vi $HOME/.ssh/config

Add/Append the following config option for a shortcut to server1 as per our sample setup:

    Host server1
         HostName server1.cyberciti.biz
         User nixcraft
         Port 4242
         IdentityFile /nfs/shared/users/nixcraft/keys/server1/id_rsa

Save and close the file. To open your new SSH session to server1.cyberciti.biz by typing the following command:

    $ ssh server1

Adding another host
Append the following to your `~/.ssh/config` file:

    Host nas01
         HostName 192.168.1.100
         User root
         IdentityFile ~/.ssh/nas01.key

You can simply type:
    
    $ ssh nas01

Putting it all together

Here is my sample `~/.ssh/config` file that explains and create, design, and evaluate different needs for remote access using ssh client:

    ### default for all 
    Host *
         ForwardAgent no
         ForwardX11 no
         ForwardX11Trusted yes
         User nixcraft
         Port 22
         Protocol 2
         ServerAliveInterval 120
         ServerAliveCountMax 30
    ## the above config means will refresh every 2 minutes for a maximum of 30 consecutive times. That means, it will stop refreshing after an hour. This works from your client regardless of what your server has configured. 
    
    ## override as per host 
    Host server1
         HostName server1.cyberciti.biz
         User nixcraft
         Port 4242
         IdentityFile /nfs/shared/users/nixcraft/keys/server1/id_rsa
     
    ## Home nas server 
    Host nas01
         HostName 192.168.1.100
         User root
         IdentityFile ~/.ssh/nas01.key
     
    ## Login AWS Cloud 
    Host aws.apache
         HostName 1.2.3.4
         User wwwdata
         IdentityFile ~/.ssh/aws.apache.key
     
    ## Login to internal lan server at 192.168.0.251 via our public uk office ssh based gateway using 
    ## $ ssh uk.gw.lan 
    Host uk.gw.lan uk.lan
         HostName 192.168.0.251
         User nixcraft
         ProxyCommand  ssh nixcraft@gateway.uk.cyberciti.biz nc %h %p 2> /dev/null
     
    ## Our Us Proxy Server 
    ## Forward all local port 3128 traffic to port 3128 on the remote vps1.cyberciti.biz server 
    ## $ ssh -f -N  proxyus 
    Host proxyus
        HostName vps1.cyberciti.biz
        User breakfree
        IdentityFile ~/.ssh/vps1.cyberciti.biz.key
        LocalForward 3128 127.0.0.1:3128

**Understanding `~/.ssh/config` entries**

- **Host** : Defines for which host or hosts the configuration section applies. The section ends with a new Host section or the end of the file. A single * as a pattern can be used to provide global defaults for all hosts.

- **HostName** : Specifies the real host name to log into. Numeric IP addresses are also permitted.

- **User** : Defines the username for the SSH connection.

- **IdentityFile** : Specifies a file from which the user’s **DSA**, **ECDSA** or **DSA** authentication identity is read. The default is `~/.ssh/identity`for **protocol version 1**, and `~/.ssh/id_dsa`, `~/.ssh/id_ecdsa` and `~/.ssh/id_rsa` for **protocol version 2**.

- **ProxyCommand** : Specifies the command to use to connect to the server. The command string extends to the end of the line, and is executed with the user’s shell. In the command string, any occurrence of %h will be substituted by the host name to connect, %p by the port, and %r by the remote user name. The command can be basically anything, and should read from its standard input and write to its standard output. This directive is useful in conjunction with **nc(1)** and its proxy support. For example, the following directive would connect via an **HTTP proxy at 192.1.0.253**:

        ProxyCommand /usr/bin/nc -X connect -x 192.1.0.253:3128 %h %p

- **LocalForward** : Specifies that a **TCP** port on the local machine be forwarded over the secure channel to the specified host and port from the remote machine. The first argument must be **`[bind_address:]port`** and the second argument must be **`host:hostport`**.

- **Port** : Specifies the port number to connect on the remote host.

- **ServerAliveInterval** : Sets a timeout interval in seconds after which if no data has been received from the server, ssh(1) will send a message through the encrypted channel to request a response from the server. See blogpost **“Open SSH Server connection drops out after few or N minutes of inactivity”** for more information.

- **ServerAliveCountMax** : Sets the number of server alive messages which may be sent without ssh(1) receiving any messages back from the server. If this threshold is reached while server alive messages are being sent, ssh will disconnect from the server, terminating the session.


## Keeping Connections Alive to Avoid Timeout

If you find yourself being disconnected from SSH sessions before you are ready, it is possible that your connection is timing out.

You can configure your client to send a packet to the server every so often in order to avoid this situation:

On your local computer, you can configure this for every connection by editing your `~/.ssh/config` file. Open it now:

    $ sudo vi ~/.ssh/config

If one does not already exist, at the top of the file, define a section that will match all hosts. Set the `ServerAliveInterval` to **"120"** to send a packet to the server every two minutes. This should be enough to notify the server not to close the connection:

    Host *
        ServerAliveInterval 120

Save and close the file when you are finished.


## Setting Up SSH Tunnels

Tunneling other traffic through a secure SSH tunnel is an excellent way to work around restrictive firewall settings. It is also a great way to encrypt otherwise unencrypted network traffic.

#### Configuring Local Tunneling to a Server

SSH connections can be used to tunnel traffic from ports on the local host to ports on a remote host.

A local connection is a way of accessing a network location from your local computer through your remote host. First, an SSH connection is established to your remote host. On the remote server, a connection is made to an external (or internal) network address provided by the user and traffic to this location is tunneled to your local computer on a specified port.

This is often used to tunnel to a less restricted networking environment by bypassing a firewall. Another common use is to access a **"localhost-only"** web interface from a remote location.

To establish a local tunnel to your remote server, you need to use the -L parameter when connecting and you must supply three pieces of additional information:

- The local port where you wish to access the tunneled connection.
- The host that you want your remote host to connect to.
- The port that you want your remote host to connect on.

These are given, in the order above (separated by colons), as arguments to the `-L` flag. We will also use the `-f` flag, which causes SSH to go into the background before executing and the `-N` flag, which does not open a shell or execute a program on the remote side.

For instance, to connect to `example.com` on port **80** on your remote host, making the connection available on your local machine on port **8888**, you could type:

    $ ssh -f -N -L 8888:example.com:80 username@remote_host

Now, if you point your local web browser to `127.0.0.1:8888`, you should see whatever content is at example.com on port 80.

A more general guide to the syntax is:

    $ ssh -L your_port:site_or_IP_to_access:site_port username@host

Since the connection is in the background, you will have to find its **PID** to kill it. You can do so by searching for the port you forwarded:

    ps aux | grep 8888
    1001      5965  0.0  0.0  48168  1136 ?        Ss   12:28   0:00 ssh -f -N -L 8888:example.com:80 username@remote_host
    1001      6113  0.0  0.0  13648   952 pts/2    S+   12:37   0:00 grep --colour=auto 8888

You can then kill the process by targeting the **PID**, which is the number in the second column of the line that matches your **SSH** command:

    $ kill 5965

Another option is to start the connection without the `-f` flag. This will keep the connection in the foreground, preventing you from using the terminal window for the duration of the forwarding. The benefit of this is that you can easily kill the tunnel by typing **`CTRL-C`**.

#### Configuring Remote Tunneling to a Server

SSH connections can be used to tunnel traffic from ports on the local host to ports on a remote host.

In a remote tunnel, a connection is made to a remote host. During the creation of the tunnel, a remote port is specified. This port, on the remote host, will then be tunneled to a host and port combination that is connected to from the local computer. This will allow the remote computer to access a host through your local computer.

This can be useful if you need to allow access to an internal network that is locked down to external connections. If the firewall allows connections out of the network, this will allow you to connect out to a remote machine and tunnel traffic from that machine to a location on the internal network.

To establish a remote tunnel to your remote server, you need to use the -R parameter when connecting and you must supply three pieces of additional information:

- The port where the remote host can access the tunneled connection.
- The host that you want your local computer to connect to.
- The port that you want your local computer to connect to.

These are given, in the order above (separated by colons), as arguments to the `-R` flag. We will also use the `-f` flag, which causes SSH to go into the background before executing and the `-N` flag, which does not open a shell or execute a program on the remote side.

For instance, to connect to `example.com` on port **80** on our local computer, making the connection available on our remote host on port **8888**, you could type:

    $ ssh -f -N -R 8888:example.com:80 username@remote_host

Now, on the remote host, opening a web browser to `127.0.0.1:8888` would allow you to see whatever content is at `example.com` on port **80**.

A more general guide to the syntax is:

    $ ssh -R remote_port:site_or_IP_to_access:site_port username@host

Since the connection is in the background, you will have to find its **PID** to kill it. You can do so by searching for the port you forwarded:

    $ ps aux | grep 8888
    1001      5965  0.0  0.0  48168  1136 ?        Ss   12:28   0:00 ssh -f -N -R 8888:example.com:80 username@remote_host
    1001      6113  0.0  0.0  13648   952 pts/2    S+   12:37   0:00 grep --colour=auto 8888

You can then kill the process by targeting the PID, which is the number in the second column, of the line that matches your SSH command:

    $ kill 5965

Another option is to start the connection without the `-f` flag. This will keep the connection in the foreground, preventing you from using the terminal window for the duration of the forwarding. The benefit of this is that you can easily kill the tunnel by typing **`CTRL-C`**.

#### Configuring Dynamic Tunneling to a Remote Server

SSH connections can be used to tunnel traffic from ports on the local host to ports on a remote host.

A dynamic tunnel is similar to a local tunnel in that it allows the local computer to connect to other resources through a remote host. A dynamic tunnel does this by simply specifying a single local port. Applications that wish to take advantage of this port for tunneling must be able to communicate using the **SOCKS** protocol so that the packets can be correctly redirected at the other side of the tunnel.

Traffic that is passed to this local port will be sent to the remote host. From there, the **SOCKS** protocol will be interpreted to establish a connection to the desired end location. This set up allows a **SOCKS-capable** application to connect to any number of locations through the remote server, without multiple static tunnels.

To establish the connection, we will pass the `-D` flag along with the local port where we wish to access the tunnel. We will also use the `-f` flag, which causes SSH to go into the background before executing and the `-N` flag, which does not open a shell or execute a program on the remote side.

For instance, to establish a tunnel on port **`7777`**, you can type:

    $ ssh -f -N -D 7777 username@remote_host

From here, you can start pointing your **SOCKS-aware** application (like a web browser), to the port you selected. The application will send its information into a socket associated with the port.

The method of directing traffic to the **SOCKS** port will differ depending on application. For instance, in Firefox, the general location is **`Preferences > Advanced > Settings > Manual proxy configurations`**. In **Chrome**, you can start the application with the `--proxy-server=` flag set. You will want to use the `localhost` interface and the port you forwarded.

Since the connection is in the background, you will have to find its **PID** to kill it. You can do so by searching for the port you forwarded:

    $ ps aux | grep 8888
    1001      5965  0.0  0.0  48168  1136 ?        Ss   12:28   0:00 ssh -f -N -D 7777 username@remote_host
    1001      6113  0.0  0.0  13648   952 pts/2    S+   12:37   0:00 grep --colour=auto 8888

You can then kill the process by targeting the **PID**, which is the number in the second column, of the line that matches your SSH command:

    $ kill 5965

Another option is to start the connection without the `-f` flag. This will keep the connection in the foreground, preventing you from using the terminal window for the duration of the forwarding. The benefit of this is that you can easily kill the tunnel by typing **`CTRL-C`**.

## Using SSH Escape Codes to Control Connections

Even after establishing an SSH session, it is possible to exercise control over the connection from within the terminal. We can do this with something called SSH escape codes, which allow us to interact with our local SSH software from within a session.

#### Forcing a Disconnect from the Client-Side (How to Exit Out of a Stuck or Frozen Session)

One of the most useful feature of **OpenSSH** that goes largely unnoticed is the ability to control certain aspects of the session from within.

These commands can be executed starting with the **`~`** control character within an **SSH session**. Control commands will only be interpreted if they are the first thing that is typed after a newline, so always press `ENTER` one or two times prior to using one.

One of the most useful controls is the ability to initiate a disconnect from the client. SSH connections are typically closed by the server, but this can be a problem if the server is suffering from issues or if the connection has been broken. By using a client-side disconnect, the connection can be cleanly closed from the client.

To close a connection from the client, use the control character **`(~)`**, with a dot. If your connection is having problems, you will likely be in what appears to be a stuck terminal session. Type the commands despite the lack of feedback to perform a client-side disconnect:

    $ [ENTER]
    $ ~.

The connection should immediately close, returning you to your local shell session.

#### Placing an SSH Session into the Background

One of the most useful feature of **OpenSSH** that goes largely unnoticed is the ability to control certain aspects of the session from within the connection.

These commands can be executed starting with the **`~`** control character from within an SSH connection. Control commands will only be interpreted if they are the first thing that is typed after a newline, so always press `ENTER` one or two times prior to using one.

One capability that this provides is to put an **SSH** session into the background. To do this, we need to supply the control character **`(~)`** and then execute the conventional keyboard shortcut to background a task **`CTRL-z`**:

    $ [ENTER]
    $ ~[CTRL-z]

This will place the connection into the background, returning you to your local shell session. To return to your SSH session, you can use the conventional job control mechanisms.

You can immediately **re-activate** your most recent backgrounded task by typing:

    $ fg
If you have multiple backgrounded tasks, you can see the available jobs by typing:

jobs
[1]+  Stopped                 ssh username@some_host
[2]   Stopped                 ssh username@another_host
You can then bring any of the tasks to the foreground by using the index in the first column with a percentage sign:

    $ fg %2

#### Changing Port Forwarding Options on an Existing SSH Connection

One of the most useful feature of **OpenSSH** that goes largely unnoticed is the ability to control certain aspects of the session from within the connection.

These commands can be executed starting with the **`~`** control character from within an SSH connection. Control commands will only be interpreted if they are the first thing that is typed after a newline, so always press `ENTER` one or two times prior to using one.

One thing that this allows is for a user to alter the port forwarding configuration after the connection has already been established. This allows you to create or tear down port forwarding rules on-the-fly.

These capabilities are part of the SSH command line interface, which can be accessed during a session by using the control character **`(~)`** and **`"C"`**:

    $ [ENTER]
    $ ~C
    $ ssh>

You will be given an SSH command prompt, which has a very limited set of valid commands. To see the available options, you can type `-h` from this prompt. If nothing is returned, you may have to increase the verbosity of your SSH output by using `~v` a few times:

    $ [ENTER]
    $ ~v
    $ ~v
    $ ~v
    $ ~C
    $ -h
    $ Commands:
        -L[bind_address:]port:host:hostport    Request local forward
        -R[bind_address:]port:host:hostport    Request remote forward
        -D[bind_address:]port                  Request dynamic forward
        -KL[bind_address:]port                 Cancel local forward
        -KR[bind_address:]port                 Cancel remote forward
        -KD[bind_address:]port                 Cancel dynamic forward

As you can see, you can easily implement any of the forwarding options using the appropriate options (see the forwarding section for more information). You can also destroy a tunnel with the associated **`kill`** command specified with a **`K`** before the forwarding type letter. For instance, to kill a local forward **`(-L)`**, you could use the **`-KL`** command. You will only need to provide the port for this.

So, to set up a local port forward, you may type:

    $ [ENTER]
    $ ~C
    $ -L 8888:127.0.0.1:80

Port **8888** on your local computer will now be able to communicate with the web server on the host you are connecting to. When you are finished, you can tear down that forward by typing:

    $ [ENTER]
    $ ~C
    $ -KL 8888

